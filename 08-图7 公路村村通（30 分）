#include<stdio.h>
#include<stdlib.h>
#define MAXVERTEX 1000
#define INF 99999

int Cost[MAXVERTEX + 1];

typedef struct MGraph {
	int N_Vertex, N_Edge;
	int Edge[MAXVERTEX + 1][MAXVERTEX + 1];
}*MGraph;

typedef struct Edge {
	int V1, V2, Cost;
}Edge;

MGraph Cre_MGraph() {
	MGraph G = (MGraph)malloc(sizeof(struct MGraph));
	Edge edge;
	scanf("%d %d\n", &G->N_Vertex, &G->N_Edge);
	for (int i = 1; i <= G->N_Vertex; i++) {
		for (int j = 1; i <= G->N_Vertex; i++) {
			G->Edge[i][j] = INF;
		}
	}
	for (int i = 1; i <G->N_Edge; i++) {
		scanf("%d %d %d\n", &edge.V1, &edge.V2, &edge.Cost);
		G->Edge[edge.V1][edge.V2] = edge.Cost;
		G->Edge[edge.V2][edge.V1] = edge.Cost;
	}
	scanf("%d %d %d", &edge.V1, &edge.V2, &edge.Cost);
	G->Edge[edge.V1][edge.V2] = edge.Cost;
	G->Edge[edge.V2][edge.V1] = edge.Cost;
	return G;
}

int FindMin(MGraph G) {
	int index=0, min = INF;
	for (int i = 1; i <= G->N_Vertex; i++) {
		if (Cost[i] < min&&Cost[i]!=0) {
			index = i;
			min = Cost[i];
		}
	}
	return index;
}


int Prim(MGraph G) {
	int index,count=0,total_cost=0;
	while(1){
	index = FindMin(G);
	if (index == 0) break;
	else {
		count++;
		total_cost += Cost[index];
		for (int i = 1; i <= G->N_Vertex; i++) {
			if (Cost[i] != 0&&G->Edge[index][i]!=INF) {/*对于每一个未被收录的邻接顶点*/
				if (G->Edge[index][i] < Cost[i]) {
					Cost[i] = G->Edge[index][i];
				}
			}
		}
		Cost[index] = 0;
	}
	}
	return (count == G->N_Vertex - 1) ? total_cost : -1;/*如果收到的顶点不足N-1个，生成树不存在，返还-1，否则返还最小生成树的total_cost*/
}

int main() {
	MGraph G = Cre_MGraph();
	Cost[1] = 0;/*从下标为1的顶点出发生成最小生成树*/
	for (int i = 2; i <= G->N_Vertex; i++) {/*初始化邻接矩阵及Cost数组*/
		Cost[i] = G->Edge[1][i];
	}
	int Result = Prim(G);
	free(G);
	printf("%d", Result);
	return 0;
}
